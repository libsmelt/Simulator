diff --git a/tools/harness/scalebench.py b/tools/harness/scalebench.py
--- a/tools/harness/scalebench.py
+++ b/tools/harness/scalebench.py
@@ -1,4 +1,4 @@
-#!/usr/bin/env python
+#!/usr/bin/env python2.7
 
 ##########################################################################
 # Copyright (c) 2009, 2011, ETH Zurich.
diff --git a/tools/harness/tests/__init__.py b/tools/harness/tests/__init__.py
--- a/tools/harness/tests/__init__.py
+++ b/tools/harness/tests/__init__.py
@@ -46,4 +46,4 @@
     skew, tsctests, vmkit, nfscat, mdbbench, \
     rcce, bulktests, tracing, buildall, bomp_sidebyside, \
     monitortest, phases, clockdrift, channel_cost, fputest, TimerTest, \
-    multihoptests, perfmontest, freemem, spawntest, spantest
+    multihoptests, perfmontest, freemem, spawntest, spantest, ump_latency
diff --git a/usr/bench/ump_bench/Hakefile b/usr/bench/ump_bench/Hakefile
--- a/usr/bench/ump_bench/Hakefile
+++ b/usr/bench/ump_bench/Hakefile
@@ -18,5 +18,10 @@
   build application { target = "ump_send", cFiles = [ "main.c" , "send.c" ],
                       flounderDefs = [ "monitor" ],
                       flounderBindings = [ "bench" ],
+                      addLibraries = ["bench"] },
+  
+  build application { target = "ump_receive", cFiles = [ "main.c" , "receive.c" ],
+                      flounderDefs = [ "monitor" ],
+                      flounderBindings = [ "bench" ],
                       addLibraries = ["bench"] }
 ]
diff --git a/usr/quorum/Hakefile b/usr/quorum/Hakefile
--- a/usr/quorum/Hakefile
+++ b/usr/quorum/Hakefile
@@ -14,7 +14,8 @@
                         "main.c", 
                         "qrm_mgmt.c",
                         "exp_ab.c",
-                        "mgmt_connection.c"
+                        "mgmt_connection.c",
+                        "shm_fifo_queue.c"
                         ],
                       flounderDefs = [ "monitor" ],
                       flounderBindings = [ "quorum", "quorum_mgmt" ],
diff --git a/usr/quorum/main.c b/usr/quorum/main.c
--- a/usr/quorum/main.c
+++ b/usr/quorum/main.c
@@ -304,7 +304,7 @@
  * grml: why the f**k does this not work with anything else but the
  * default waitset?
  */
-static int qrm_init(void)
+static int __attribute__((unused)) qrm_init(void)
 {
     errval_t err;
     iref_t iref;
@@ -578,7 +578,11 @@
     qrm_init_finish_round();
 
     uint64_t ts = rdtsc();
+
+#if defined(EXP_MP)
     qrm_init();
+#endif /* EXP_MP */
+
     printf("qrm_init %d done after %"PRIu64"\n", my_core_id, rdtsc()-ts);
 
 #if defined(CONFIG_TRACE)
@@ -589,9 +593,15 @@
     QDBG("Tracing enabled on core %d\n", my_core_id);
 #endif /* CONFIG_TRACE */
 
-    printf("STEP %2d starting experiments\n", my_core_id);
+#if defined(EXP_SHM)
+    printf("STEP %2d starting SHM experiments\n", my_core_id);
+    exp_shm_fifo();
+#endif /* EXP_SHM */
 
+#if defined(EXP_MP)
+    printf("STEP %2d starting MP experiments\n", my_core_id);
     exp_ac();
+#endif /* EXP_MP */
 
     QDBG("All experiments done, exiting\n");
 
diff --git a/usr/quorum/mgmt_connection.c b/usr/quorum/mgmt_connection.c
--- a/usr/quorum/mgmt_connection.c
+++ b/usr/quorum/mgmt_connection.c
@@ -51,7 +51,7 @@
     
     // Receive capref and map
     shared_frame = sm;
-    err = vspace_map_one_frame_attr(((void**)&share), 4096, shared_frame,
+    err = vspace_map_one_frame_attr(((void**)&share), SHM_SIZE, shared_frame,
                                     VREGION_FLAGS_READ_WRITE, NULL, NULL);
     assert(err_is_ok(err));
 
diff --git a/usr/quorum/qrm_mgmt.c b/usr/quorum/qrm_mgmt.c
--- a/usr/quorum/qrm_mgmt.c
+++ b/usr/quorum/qrm_mgmt.c
@@ -94,12 +94,13 @@
 
     // Create a frame cap to be used as shared memory for synchronization 
     // of experiments and debugging
-    err = frame_alloc(&shared_frame, 4096, NULL);
+    err = frame_alloc(&shared_frame, SHM_SIZE, NULL);
     assert(err_is_ok(err));
 
     // Map frame
-    assert(sizeof(union quorum_share)==4096); // Make sure shared page is 4K
-    err = vspace_map_one_frame_attr(((void**)&share), 4096, shared_frame, 
+    assert(SHM_SIZE % BASE_PAGE_SIZE==0);
+    assert(sizeof(union quorum_share)<=SHM_SIZE);
+    err = vspace_map_one_frame_attr(((void**)&share), SHM_SIZE, shared_frame, 
                                     VREGION_FLAGS_READ_WRITE, NULL, NULL);
     assert(err_is_ok(err));
 
diff --git a/usr/quorum/quorum.h b/usr/quorum/quorum.h
--- a/usr/quorum/quorum.h
+++ b/usr/quorum/quorum.h
@@ -15,6 +15,8 @@
 #ifndef QUORUM_H
 #define QUORUM_H
 
+#include "shm.h"
+
 #include <barrelfish_kpi/types.h>
 #include <barrelfish/barrelfish.h>
 #include <barrelfish/waitset.h>
@@ -31,6 +33,9 @@
 #define QRM_ROUND_MAX 1000
 #define RAW_UMP 1
 #define SEQUENTIALIZER 0 // node that acts as the sequentializer
+#define SHM_SIZE (4096*1024) // 4 MB
+#define EXP_MP 1
+//#define EXP_SHM 1
 //#define QRM_DBG_ENABLED 1
 
 // --------------------------------------------------
@@ -56,9 +61,13 @@
         // as different counters are never used concurrently anyway
         spinlock_t __attribute__ ((aligned(64))) lock;
         uint8_t __attribute__ ((aligned(32))) rounds[QRM_ROUND_MAX];
+
+        // FIFO
+        // Currently shared by all cores
+        struct ump_message __attribute__((aligned(64))) fifo[SHM_Q_MAX];
     } data;
     // Raw
-    uint8_t raw[4096];
+    uint8_t raw[4096]; // << don't really need this
 };
 
 
@@ -91,4 +100,7 @@
 // management process (qrm_mgmt)
 int mgmt_loop(void* st);
 
+// shm
+int exp_shm_fifo(void);
+
 #endif // QUORUM_H
diff --git a/usr/quorum/shm_fifo_queue.c b/usr/quorum/shm_fifo_queue.c
new file mode 100644
--- /dev/null
+++ b/usr/quorum/shm_fifo_queue.c
@@ -0,0 +1,97 @@
+/*
+ * Copyright (c) 2007, 2008, 2009, 2010, 2011, 2012, 2013 ETH Zurich.
+ * All rights reserved.
+ *
+ * This file is distributed under the terms in the attached LICENSE file.
+ * If you do not find this file, copies can be found by writing to:
+ * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich. Attn: Systems Group.
+ */
+
+#include "shm.h"
+#include "quorum.h"
+
+#include <barrelfish_kpi/types.h>
+#include <barrelfish/barrelfish.h>
+#include <barrelfish/ump_impl.h>
+
+#include <stdio.h>
+#include <measurement_framework.h>
+
+extern union quorum_share *share;
+
+static int round = 0;
+
+static uint64_t m_buf[NUM_REPETITIONS];
+static struct sk_measurement m;
+
+/*
+ * \brief Send a message via queue
+ *
+ */
+static void send(void)
+{
+    assert(round<SHM_Q_MAX);
+
+    // Get next slot and increment
+    volatile struct ump_message *msg = &share->data.fifo[round++];
+
+    // Prepare header used to send a message
+    struct ump_control ctrl = { .epoch = 1, .header = 0 };
+
+    // Write tsc on message (works only on 64 bit machines)
+    assert(sizeof(uintptr_t) == sizeof(uint64_t));
+    msg->data[0] = rdtsc();
+
+    // Send
+    msg->header.control = ctrl;
+}
+
+/*
+ * \brief Receive a message via queue
+ *
+ */
+static void receive(void)
+{
+    assert(round<SHM_Q_MAX);
+
+    // Get next slot and increment
+    volatile struct ump_message *msg = &share->data.fifo[round++];
+
+    uint64_t stamp;
+
+    // Wait for epoch bit to indicate send
+    do {
+        stamp = rdtsc();
+    } while (msg->header.control.epoch==0);
+
+    // Measurement
+    sk_m_add_value(&m, rdtsc()-stamp); //msg->data[0]);
+}
+
+/*
+ * \brief 
+ *
+ */
+int exp_shm_fifo(void)
+{
+    sk_m_init(&m, SHM_Q_MAX, "shm_fifo", m_buf);
+
+    if (disp_get_core_id()==SEQUENTIALIZER) {
+        // Sender
+        for (int i=0; i<SHM_Q_MAX; i++) {
+
+            send();
+        }
+    } else {
+        // Receiver
+        for (int i=0; i<SHM_Q_MAX; i++) {
+
+            receive();
+        }
+        sk_m_print(&m);
+    }
+
+
+    printf("EXP_SHM_FIFO terminated on %d\n", disp_get_core_id());
+    return 0;
+}
