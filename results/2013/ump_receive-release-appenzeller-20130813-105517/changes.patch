diff --git a/include/tools/tools.h b/include/tools/tools.h
--- a/include/tools/tools.h
+++ b/include/tools/tools.h
@@ -11,8 +11,68 @@
 #ifndef TOOLS_H
 #define TOOLS_H 1
 
+#include <barrelfish/barrelfish.h>
+
 void sleep_tsc(uint64_t tics);
 void barrier_wait(int num);
 void printff(const char *fmt, ...);
 
+# define DEBUG_ERRR(err, msg...) debug_errr(__FILE__, __func__, __LINE__, err, msg)
+void debug_errr(const char *file, const char *func, int line, errval_t err,
+                const char *msg, ...);
+
+// Print return address
+/* extern void sys_print(const char *, size_t); */
+/* #include <sys/types.h> */
+/* #include <sys/stat.h> */
+/* #include <sys/times.h> */
+/* #include <errno.h> */
+/* #include <stdio.h> */
+/* #include <stdlib.h> */
+#define DBG_RETURN_ADDR(x)  {                                    \
+        char dbg_ret_addr_str[50];                               \
+        void* dbg_ret_addr = __builtin_return_address (0);       \
+        sprintf(dbg_ret_addr_str, "ret %p\n", dbg_ret_addr_str); \
+        sys_print(dbg_ret_addr_str, strlen(dbg_ret_addr_str));   \
+        dbg_ret_addr = __builtin_return_address (1);       \
+        sprintf(dbg_ret_addr_str, "ret %p\n", dbg_ret_addr_str); \
+        sys_print(dbg_ret_addr_str, strlen(dbg_ret_addr_str));   \
+        dbg_ret_addr = __builtin_return_address (2);       \
+        sprintf(dbg_ret_addr_str, "ret %p\n", dbg_ret_addr_str); \
+        sys_print(dbg_ret_addr_str, strlen(dbg_ret_addr_str));   \
+    }
+
+// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
+// This should be use to prevent scalebench from hake'ing every time it runs.
+// This is meant to be used for bug-fixing, when scalebench is
+// repeatedly executed on the same build directory.
+//
+// USE WITH CARE! Scalebench will _not_ change the hake configuration for the 
+// given build directory any longer
+// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
+/* diff -r 4c475012e1b0 tools/harness/builds.py */
+/* --- a/tools/harness/builds.py	Thu Aug 08 13:23:02 2013 +0200 */
+/* +++ b/tools/harness/builds.py	Thu Aug 08 13:56:07 2013 +0200 */
+/* @@ -105,12 +105,12 @@ */
+/*      def configure(self, checkout, archs): */
+/*          srcdir = checkout.get_base_dir() */
+/*          self._make_build_dir() */
+/* -        self._write_hake_conf(srcdir, archs) */
+/* -        self._run_hake(srcdir, archs) */
+/* +        # self._write_hake_conf(srcdir, archs) */
+/* +        # self._run_hake(srcdir, archs) */
+/* */ 
+/* -        # this should be a nop -- building it here causes us to stop early */
+/* -        # with any tool or dependency-generation errors before doing test setup */
+/* -        self.build(["Makefile"]) */
+/* +        # # this should be a nop -- building it here causes us to stop early */
+/* +        # # with any tool or dependency-generation errors before doing test setup */
+/* +        # self.build(["Makefile"]) */
+/* */ 
+/*      @staticmethod */
+/*      def split_env(e): */
+// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
+
+
+
 #endif /* TOOLS_H */
diff --git a/lib/idc/ump_chan.c b/lib/idc/ump_chan.c
--- a/lib/idc/ump_chan.c
+++ b/lib/idc/ump_chan.c
@@ -254,7 +254,6 @@
 
 #ifdef UMP_NUMA_AWARE
     if (numa) {
-        printf("NUMA aware bind on core %d\n", disp_get_core_id());
         err = numa_frame_alloc_local(&uc->frame, framesize);
     } else {
         err = frame_alloc(&uc->frame, framesize, &framesize);
diff --git a/lib/numa/numa.c b/lib/numa/numa.c
--- a/lib/numa/numa.c
+++ b/lib/numa/numa.c
@@ -25,8 +25,6 @@
 
     ram_get_affinity(&old_base, &old_limit);
     ram_set_affinity(base, limit);
-    printf("libnuma: alloca mem at %"PRIxGENPADDR" limit %"PRIxGENPADDR"\n",
-           base, limit);
     err = ram_alloc(&ram, bits);
     ram_set_affinity(old_base, old_limit);
     if (err_is_fail(err)) {
diff --git a/lib/tools/tools.c b/lib/tools/tools.c
--- a/lib/tools/tools.c
+++ b/lib/tools/tools.c
@@ -78,6 +78,38 @@
     printf(str, sizeof(str));
 }
 
+void debug_errr(const char *file, const char *func, int line, errval_t err,
+               const char *msg, ...)
+{
+    // Do not do anything in case there is no error
+    if (err_is_ok(err)) {
+        return;
+    }
+
+    va_list ap;
+
+    char str[256];
+    int strcc;
+    char *leader = (err == 0) ? "SUCCESS" : "ERROR";
+    strcc = snprintf(str, sizeof(str), "%s: %.*s.%u in %s() %s:%d\n%s: ",
+                     leader, DISP_NAME_LEN, disp_name(), disp_get_core_id(),
+                     func, file, line, leader);
+    sys_print(str, sizeof(str));
+
+    if (msg != NULL) {
+        va_start(ap, msg);
+        strcc = vsnprintf(str, sizeof(str), msg, ap);
+        va_end(ap);
+        sys_print(str, sizeof(str));
+    }
+    sys_print("\n", 1);
+
+    if (err != 0) {
+        err_print_calltrace(err);
+    }
+}
+
+
 /*
  * \brief Dump content of SKB for debugging purpose
  *
diff --git a/tools/harness/harness.py b/tools/harness/harness.py
--- a/tools/harness/harness.py
+++ b/tools/harness/harness.py
@@ -29,17 +29,19 @@
         test.setup(build, machine, path)
         debug.verbose('harness: run test')
         starttime = datetime.datetime.now()
-        for out in test.run(build, machine, path):
-            # timedelta for the time this line was emitted from the start of the run
-            timestamp = datetime.datetime.now() - starttime
-            # format as string, discarding sub-second precision
-            timestr = str(timestamp).split('.', 1)[0]
-            # filter output line of control characters
-            filtered_out = filter(lambda c: c in string.printable, out.rstrip())
-            # debug filtered output along with timestamp
-            debug.debug('[%s] %s' % (timestr, filtered_out))
-            # log full raw line (without timestamp) to output file
-            raw_file.write(out)
+        for i in range(48):
+            print 'Running benchmark with server core on %d' % i
+            for out in test.run(build, machine, path, i):
+                # timedelta for the time this line was emitted from the start of the run
+                timestamp = datetime.datetime.now() - starttime
+                # format as string, discarding sub-second precision
+                timestr = str(timestamp).split('.', 1)[0]
+                # filter output line of control characters
+                filtered_out = filter(lambda c: c in string.printable, out.rstrip())
+                # debug filtered output along with timestamp
+                debug.debug('[%s] %s' % (timestr, filtered_out))
+                # log full raw line (without timestamp) to output file
+                raw_file.write(out)
         debug.verbose('harness: output complete')
     except KeyboardInterrupt:
         # let the user know that we are on our way out
diff --git a/tools/harness/tests/rpctests.py b/tools/harness/tests/rpctests.py
--- a/tools/harness/tests/rpctests.py
+++ b/tools/harness/tests/rpctests.py
@@ -23,13 +23,17 @@
         modules.add_module(self.get_module_name())
         return modules
 
-    def run(self, build, machine, testdir):
+    def run(self, build, machine, testdir, core):
         modules = self.get_modules(build, machine)
+
+        assert self.benchmark_type == None
+
         args = []
         if self.benchmark_type != None:
             args = [str(self.benchmark_type)]
-        modules.reset_module(self.get_module_name(), args)
+        modules.reset_module(self.get_module_name(), ['core=%d' % core])
         self.boot(machine, modules)
+        self.set_timeout(None)
         return self.collect_data(machine)
 
     def process_data(self, testdir, rawiter):
diff --git a/tools/harness/tests/ump_latency.py b/tools/harness/tests/ump_latency.py
--- a/tools/harness/tests/ump_latency.py
+++ b/tools/harness/tests/ump_latency.py
@@ -80,10 +80,7 @@
                 if l:
                     cl = crop_list(l, .3)
                     r = array(cl)
-                    if r.mean()<2000:
-                        (mean, std) = (r.mean(), r.std())
-                    else:
-                        (mean, std) = (-1, 0)
+                    (mean, std) = (r.mean(), r.std())
                 else:
                     (mean, std) = (-1, 0)
                 res.add_row([x, y, mean, std])
diff --git a/usr/bench/ump_bench/Hakefile b/usr/bench/ump_bench/Hakefile
--- a/usr/bench/ump_bench/Hakefile
+++ b/usr/bench/ump_bench/Hakefile
@@ -1,27 +1,25 @@
 --------------------------------------------------------------------------
--- Copyright (c) 2007-2013, ETH Zurich.
+-- Copyright (c) 2007-2009, ETH Zurich.
 -- All rights reserved.
 --
 -- This file is distributed under the terms in the attached LICENSE file.
 -- If you do not find this file, copies can be found by writing to:
--- ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich. Attn: Systems Group.
+-- ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
 --
 -- Hakefile for /usr/bench/ump_bench
 --
 --------------------------------------------------------------------------
 
-[ build application { target = "ump_latency", cFiles = [ "main.c" , "latency.c" ],
+[
+  build application { target = "ump_send", cFiles = [ "main.c" , "send.c" ],
                       flounderDefs = [ "monitor" ],
                       flounderBindings = [ "bench" ],
                       addLibraries = ["bench","tools","idc_numa","numa"] },
 
-  build application { target = "ump_send", cFiles = [ "main.c" , "send.c" ],
-                      flounderDefs = [ "monitor" ],
-                      flounderBindings = [ "bench" ],
-                      addLibraries = ["bench","tools","idc_numa","numa"] },
-  
+
   build application { target = "ump_receive", cFiles = [ "main.c" , "receive.c" ],
                       flounderDefs = [ "monitor" ],
                       flounderBindings = [ "bench" ],
                       addLibraries = ["bench","tools","idc_numa","numa"] }
+
 ]
diff --git a/usr/bench/ump_bench/latency.c b/usr/bench/ump_bench/latency.c
--- a/usr/bench/ump_bench/latency.c
+++ b/usr/bench/ump_bench/latency.c
@@ -14,11 +14,9 @@
 
 #include "ump_bench.h"
 
+#define MAX_COUNT 1000
 static struct timestamps *timestamps;
 
-/*
- * Experiment, this loop is running on the server
- */
 void experiment(coreid_t idx)
 {
     timestamps = malloc(sizeof(struct timestamps) * MAX_COUNT);
diff --git a/usr/bench/ump_bench/main.c b/usr/bench/ump_bench/main.c
--- a/usr/bench/ump_bench/main.c
+++ b/usr/bench/ump_bench/main.c
@@ -4,18 +4,16 @@
  */
 
 /*
- * Copyright (c) 2007, 2008, 2009, 2010, 2011, 2012, 2013, ETH Zurich.
+ * Copyright (c) 2007, 2008, 2009, ETH Zurich.
  * All rights reserved.
  *
  * This file is distributed under the terms in the attached LICENSE file.
  * If you do not find this file, copies can be found by writing to:
- * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich. Attn: Systems Group.
+ * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
  */
 
 #include "ump_bench.h"
-#include <stdlib.h>
 #include <string.h>
-#include <stdbool.h>
 #include <barrelfish/nameservice_client.h>
 #include <barrelfish/spawn_client.h>
 #include <skb/skb.h>
@@ -25,9 +23,6 @@
 static coreid_t num_cores;
 static char my_name[100];
 
-static coreid_t sending_core;
-static bool exp_done = false;
-
 struct bench_binding *array[MAX_CPUS] = {NULL};
 coreid_t my_core_id;
 
@@ -37,17 +32,22 @@
     count++;
     array[id] = b;
 
+    printf("ump_init_msg from core %d, got %d, num_cores is %d\n", 
+           my_core_id, count, num_cores);
+
     // All clients connected, run experiment
     if (count + 1 == num_cores) {
+
+        printf("Everyone connected\n");
+
         for (coreid_t i = 0; i < MAX_CPUS; i++) {
             if (array[i]) {
+                printf("Staring experiment for core %d\n", i);
                 experiment(i);
             }
         }
 
         printf("client done\n");
-        exp_done = true;
-        count = 0;
     }
 }
 
@@ -57,10 +57,14 @@
 
 static void bind_cb(void *st, errval_t binderr, struct bench_binding *b)
 {
+    printf("bind_cb\n");
+
     errval_t err;
     err = b->tx_vtbl.ump_init_msg(b, NOP_CONT, my_core_id);
     assert(err_is_ok(err));
 
+    printf("init message send on core %d\n", my_core_id);
+
     struct bench_ump_binding *bu = (struct bench_ump_binding*)b;
     struct flounder_ump_state *fus = &bu->ump_state;
     struct ump_chan *chan = &fus->chan;
@@ -68,72 +72,31 @@
     struct ump_chan_state *send = &chan->send_chan;
     struct ump_chan_state *recv = &chan->endpoint.chan;
 
-#ifdef SERVERCOST
-    timestamps = malloc(sizeof(struct timestamps)*MAX_COUNT);
-    assert(timestamps != NULL);
-    int i = 0;
-#endif /* SERVERCOST */
-
-    int num = 0;
-
-    /* Wait for and reply to msgs (i.e. echo server) */
-    /* This is running on _ALL_ the client! */
-    while (!exp_done) {
+    /* Wait for and reply to msgs */
+    while (1) {
         volatile struct ump_message *msg;
         struct ump_control ctrl;
-        do {
-#ifdef SERVERCOST            
-            timestamps[i].time0 = bench_tsc();
-#endif /* SERVERCOST */
-        } while (!ump_impl_recv(recv));
+        while (!ump_impl_recv(recv));
         msg = ump_impl_get_next(send, &ctrl);
         msg->header.control = ctrl;
-        
-#ifdef SERVERCOST
-        timestamps[i].time1 = bench_tsc();
-
-        if (++i==MAX_COUNT) { // We _should_ receive MAX_COUNT messages ..
-
-            for (int j = MAX_COUNT / 10; j < MAX_COUNT; j++) {
-                printf("client: page %d client %d took %ld\n", j,
-                       my_core_id,
-                       timestamps[j].time1 - bench_tscoverhead() -
-                       timestamps[j].time0);
-            }
-
-            i = 0;
-            printf("client: Running\n");
-        }
-#endif /* SERVERCOST */
-
-        // sending core is sending MAX_COUNT to every client
-        if (++num == MAX_COUNT) { 
-            exp_done = true;
-        }
-
-
     }
-
 }
 
 static void export_cb(void *st, errval_t err, iref_t iref)
 {
+    printf("Export done with status %d\n", err_is_fail(err));
     if (err_is_fail(err)) {
         DEBUG_ERR(err, "export failed");
         abort();
     }
 
-    assert(sending_core == my_core_id);
-
-    char buf[1000];
-    sprintf(buf, "ump_server%d", sending_core);
-
     // register this iref with the name service
-    err = nameservice_register(buf, iref);
+    err = nameservice_register("ump_server", iref);
     if (err_is_fail(err)) {
         DEBUG_ERR(err, "nameservice_register failed");
         abort();
     }
+    printf("Nameserver registration done\n");
 }
 
 static errval_t connect_cb(void *st, struct bench_binding *b)
@@ -145,30 +108,17 @@
     return SYS_ERR_OK;
 }
 
-/*
- * \brief Get number of cores from SKB
- */
-static int get_num_cores(void)
+static void num_cores_reply(struct monitor_binding *b, coreid_t num)
 {
-    errval_t err;
-    int nr_available_cores;
-    err = skb_execute("available_nr_cores(Nr),write(nrcores(Nr)).");
-    if (err_is_fail(err)) {
-        DEBUG_ERR(err, "Could not determine the number of cores."
-                "Stay with one core...\n");
-    }
-    err = skb_read_output("nrcores(%d)", &nr_available_cores);
-    if (err_is_fail(err)) {
-        DEBUG_ERR(err, "Could not determine the number of cores <2>."
-                "Stay with one core...\n");
-    }
-    return nr_available_cores;
+    // Set num cores
+    num_cores = num;
 }
 
-
 int main(int argc, char *argv[])
 {
     errval_t err;
+    struct monitor_binding *mb = get_monitor_binding();
+
 
     // Connect SKB
     err = skb_client_connect();
@@ -182,10 +132,9 @@
     strcpy(my_name, argv[0]);
 
     bench_init();
-    num_cores = get_num_cores();
-    
-    // Start all other clients
+
     if (argc == 1) { /* bsp core */
+        mb->rx_vtbl.num_cores_reply = num_cores_reply;
 
         /* 1. set num_cores,
            2. spawn domains,
@@ -193,6 +142,16 @@
            4. wait for all clients to connect,
            5. run experiments
         */
+        /* err = mb->tx_vtbl.num_cores_request(mb, NOP_CONT); */
+        /* assert(err_is_ok(err)); */
+
+        /* while (num_cores == 0) { // XXX */
+        /*     messages_wait_and_handle_next(); */
+        /* } */
+        printf("ASSUMING 48 CORES!!!!!!!!!!\n");
+        num_cores = 48;
+
+        printf("Spawning program on all cores\n");
 
         // Spawn domains
         char *xargv[] = {my_name, "dummy", NULL};
@@ -200,72 +159,33 @@
                                          SPAWN_FLAGS_DEFAULT, NULL);
         DEBUG_ERR(err, "spawn program on all cores");
         assert(err_is_ok(err));
+
+        printf("exporting .. \n");
+
+        /* Setup a server */
+        err = bench_export(NULL, export_cb, connect_cb, get_default_waitset(),
+                           IDC_BIND_FLAGS_DEFAULT);
+        assert(err_is_ok(err));
+    } else {
+        /* Connect to the server */
+        iref_t iref;
+
+        printf("Looking up ump_server on core=%d\n", my_core_id);
+        err = nameservice_blocking_lookup("ump_server", &iref);
+        if (err_is_fail(err)) {
+            DEBUG_ERR(err, "nameservice_blocking_lookup failed");
+            abort();
+        }
+
+        printf("Bind on core %d\n", my_core_id);
+        err = bench_bind(iref, bind_cb, NULL,
+                         get_default_waitset(), IDC_BIND_FLAGS_DEFAULT | \
+                         IDC_BIND_FLAG_NUMA_AWARE);
+        if (err_is_fail(err)) {
+            DEBUG_ERR(err, "bind failed");
+            abort();
+        }
     }
 
-    barrier_wait(num_cores);
-    
-    for (sending_core=0; sending_core<num_cores; sending_core++) {
-
-        sleep_tsc(10000);
-
-        exp_done = false;
-
-        if (sending_core == my_core_id) {
-
-            /* Setup a server */
-            err = bench_export(NULL, export_cb, connect_cb, 
-                               get_default_waitset(), IDC_BIND_FLAGS_DEFAULT);
-            assert(err_is_ok(err));
-
-
-        } else {
-
-            /* Connect to the server */
-            iref_t iref;
-
-            char buf[1000];
-            sprintf(buf, "ump_server%d", sending_core);
-
-            err = nameservice_blocking_lookup(buf, &iref);
-            if (err_is_fail(err)) {
-                DEBUG_ERR(err, "nameservice_blocking_lookup failed");
-                abort();
-            }
-            
-            err = bench_bind(iref, bind_cb, NULL, get_default_waitset(), 
-                             IDC_BIND_FLAGS_DEFAULT);//|IDC_BIND_FLAG_NUMA_AWARE);
-            if (err_is_fail(err)) {
-                DEBUG_ERR(err, "bind failed");
-                abort();
-            }
-                
-        }
-
-        // Run event non-blocking dispatching loop until benchmark is complete
-        // Can't use blocking calls here due to the wiredness with barriers .. 
-        while (!exp_done) {
-            err = event_dispatch_non_block(get_default_waitset());
-            
-            if (err_is_fail(err)) {
-
-                if (err_no(err) == LIB_ERR_NO_EVENT) {
-                    // No message
-
-                } else {
-                    USER_PANIC_ERR(err, "error in event_dispatch");
-                }
-            }
-
-        }
-
-        barrier_wait(num_cores); // Synchronize cores
-
-    }
-
-    barrier_wait(num_cores); // Wait for other cores
-    printff("everything done, terminating\n");
-
-    if (my_core_id==0) {
-        printf("ump_bench done\n");
-    }
+    messages_handler_loop();
 }
diff --git a/usr/bench/ump_bench/receive.c b/usr/bench/ump_bench/receive.c
--- a/usr/bench/ump_bench/receive.c
+++ b/usr/bench/ump_bench/receive.c
@@ -13,19 +13,14 @@
  */
 
 #include "ump_bench.h"
-#include <barrelfish/types.h>
 
-static struct timestamps *timestamps = NULL;
-static cycles_t *measurements = NULL;
+#define MAX_COUNT 100
+static struct timestamps *timestamps;
 
 void experiment(coreid_t idx)
 {
-    if (timestamps==NULL) {
-        timestamps = malloc(sizeof(struct timestamps) * MAX_COUNT);
-        measurements = malloc(sizeof(cycles_t) * MAX_COUNT);
-    }
-
-    assert(timestamps != NULL && measurements != NULL);
+    timestamps = malloc(sizeof(struct timestamps) * MAX_COUNT);
+    assert(timestamps != NULL);
 
     struct bench_ump_binding *bu = (struct bench_ump_binding*)array[idx];
     struct flounder_ump_state *fus = &bu->ump_state;
@@ -41,10 +36,8 @@
     struct ump_control ctrl;
 
     for (int i = 0; i < MAX_COUNT; i++) {
-        // Send message
         msg = ump_impl_get_next(send, &ctrl);
         msg->header.control = ctrl;
-        // Receive message
         while(true) {
             timestamps[i].time0 = bench_tsc();
             if (ump_impl_recv(recv)) {
@@ -56,17 +49,9 @@
 
     /* Print results */
     for (int i = MAX_COUNT / 10; i < MAX_COUNT; i++) {
-        
-        measurements[i] = timestamps[i].time1 - timestamps[i].time0 
-            - bench_tscoverhead();
-
         printf("page %d took %ld\n", i,
                timestamps[i].time1 - timestamps[i].time0
                - bench_tscoverhead());
     }
 
-    printf("%d %d %"PRIuCYCLES" %"PRIuCYCLES"\n", 
-           my_core_id, idx, bench_avg(measurements, MAX_COUNT),
-           bench_variance(measurements, MAX_COUNT));
-
 }
diff --git a/usr/bench/ump_bench/send.c b/usr/bench/ump_bench/send.c
--- a/usr/bench/ump_bench/send.c
+++ b/usr/bench/ump_bench/send.c
@@ -14,6 +14,7 @@
 
 #include "ump_bench.h"
 
+#define MAX_COUNT 100
 static struct timestamps *timestamps;
 
 void experiment(coreid_t idx)
diff --git a/usr/bench/ump_bench/ump_bench.h b/usr/bench/ump_bench/ump_bench.h
--- a/usr/bench/ump_bench/ump_bench.h
+++ b/usr/bench/ump_bench/ump_bench.h
@@ -26,7 +26,6 @@
 #include <if/bench_defs.h>
 
 #define NUM_MSGS 16
-#define MAX_COUNT 100
 
 struct timestamps {
     cycles_t time0;
diff --git a/usr/quorum/Hakefile b/usr/quorum/Hakefile
--- a/usr/quorum/Hakefile
+++ b/usr/quorum/Hakefile
@@ -19,7 +19,14 @@
                         "exp_hybrid.c" ],
                       flounderDefs = [ "monitor" ],
                       flounderBindings = [ "quorum", "quorum_mgmt" ],
-                      addLibraries = [ "skb", "octopus", "trace", "tools", "idc_numa", "numa", "bench" ],
+                      addLibraries = [ "skb", 
+                                       "octopus", 
+                                       "trace", 
+                                       "tools", 
+                                       "idc_numa", 
+                                       "numa", 
+                                       "bench", 
+                                       "collections" ],
                       addCFlags = [ "-O0" ]
                     }
 ]
diff --git a/usr/quorum/exp_ab.c b/usr/quorum/exp_ab.c
--- a/usr/quorum/exp_ab.c
+++ b/usr/quorum/exp_ab.c
@@ -57,6 +57,12 @@
 static void qrm_send_ack(void);
 #endif
 
+#ifdef MEASURE_SEND_OVERHEAD
+#define M_SEND_OVERHEAD_MAX 1000
+static struct sk_measurement m_send_overhead;
+uint64_t m_send_overhead_buf[M_SEND_OVERHEAD_MAX];
+#endif
+
 // ==================================================
 // Prototypes
 
@@ -507,13 +513,23 @@
     struct node* n = qrm_children;
     while (n!=NULL) {
 
+#       ifdef MEASURE_SEND_OVERHEAD
+        sk_m_restart_tsc(&m_send_overhead);
+#       endif
+
         send_node_payload(n, sender_core_id);
 
         num_requests++;
+        n = n->next;
+
+#       ifdef MEASURE_SEND_OVERHEAD
+        sk_m_add(&m_send_overhead);
+#       endif
+
         QDBG("message(req%d): %d->%d (sending_core_id= %d )\n", 
              num_requests, my_core_id, n->node_idx, sender_core_id);
 
-        n = n->next;
+
     }
 
 #ifdef QRM_DO_ACKS
@@ -596,54 +612,55 @@
     
     msg = ump_impl_get_next(send, &ctrl);
     (msg->data)[0] = sender_node_id;
-    msg->header.control = ctrl; // << does this actually send the message?
+
+    msg->header.control = ctrl; // << Send the message
     
 #else /* RAW_UMP */
 
-#if 0 // Busy wait for channel to become free again.
-    // XXX Test this! Does it work?
-    // Try to hack around the FLOUNDER_ERR_TX_BUSY problem 
-    // without registering any continuations. This feels more light-weight and
-    // we don't have to deal with follow ups, where we are about to register
-    // several such continuation.
-    errval_t err;
-    int i = 0;
-    do {
-        i++;
-        err = quorum_request__tx(n->binding, NOP_CONT, 
-                                          sender_node_id, n->node_idx);
-    } while(err_is_fail(err) && err_no(err)==FLOUNDER_ERR_TX_BUSY && i<1000000);
+/* #if 0 // Busy wait for channel to become free again. */
+/*     // XXX Test this! Does it work? */
+/*     // Try to hack around the FLOUNDER_ERR_TX_BUSY problem  */
+/*     // without registering any continuations. This feels more light-weight and */
+/*     // we don't have to deal with follow ups, where we are about to register */
+/*     // several such continuation. */
+/*     errval_t err; */
+/*     int i = 0; */
+/*     do { */
+/*         i++; */
+/*         err = quorum_request__tx(n->binding, NOP_CONT,  */
+/*                                           sender_node_id, n->node_idx); */
+/*     } while(err_is_fail(err) && err_no(err)==FLOUNDER_ERR_TX_BUSY && i<1000000); */
 
-    assert(err_is_ok(err));
-#endif
+/*     assert(err_is_ok(err)); */
+/* #endif */
 
-#if 1 // Try to store the arguments somewhere and 
-    errval_t err;
-    err = quorum_request__tx(n->binding, NOP_CONT, 
-                             sender_node_id, n->node_idx);
+/* #if 1 // Try to store the arguments somewhere and  */
+/*     errval_t err; */
+/*     err = quorum_request__tx(n->binding, NOP_CONT,  */
+/*                              sender_node_id, n->node_idx); */
 
-    if (err_is_fail(err) && err_no(err) == FLOUNDER_ERR_TX_BUSY) {
+/*     if (err_is_fail(err) && err_no(err) == FLOUNDER_ERR_TX_BUSY) { */
         
-        // Copy the payload
-        // XXX memory leak
-        struct send_arg *sa = malloc(sizeof(struct send_arg));
-        memcpy(sa, arg, sizeof(struct send_arg));
+/*         // Copy the payload */
+/*         // XXX memory leak */
+/*         struct send_arg *sa = malloc(sizeof(struct send_arg)); */
+/*         memcpy(sa, arg, sizeof(struct send_arg)); */
 
-        struct event_closure c = MKCONT(send_node_payload_raw, (void* ) sa);
-        err = n->binding->register_send(n->binding, &qrm_tree_ws, c);
+/*         struct event_closure c = MKCONT(send_node_payload_raw, (void* ) sa); */
+/*         err = n->binding->register_send(n->binding, &qrm_tree_ws, c); */
 
-        printf("!!!RETRANSMIT!!!\n");
-    }
-#endif
+/*         printf("!!!RETRANSMIT!!!\n"); */
+/*     } */
+/* #endif */
 
-#if 0 // Just assume that channel is never busy 
-    // XXX This does not work, assertions fail
-    errval_t err;
-    err = quorum_request__tx(n->binding, NOP_CONT, 
-                             sender_node_id, n->node_idx);
-    assert(err_is_ok(err));
-#endif
-#endif
+/* #if 0 // Just assume that channel is never busy  */
+/*     // XXX This does not work, assertions fail */
+/*     errval_t err; */
+/*     err = quorum_request__tx(n->binding, NOP_CONT,  */
+/*                              sender_node_id, n->node_idx); */
+/*     assert(err_is_ok(err)); */
+/* #endif */
+#endif /* RAW_UMP */
 
 #if defined(CONFIG_TRACE)
     trace_event(TRACE_SUBSYS_QUORUM, TRACE_EVENT_QUORUM_SEND, n->node_idx);
@@ -752,6 +769,11 @@
     uint64_t m_buf[NUM_REPETITIONS];
     sk_m_init(&m, NUM_REPETITIONS, "tree", m_buf);
 
+#ifdef MEASURE_SEND_OVERHEAD
+    sk_m_init(&m_send_overhead, M_SEND_OVERHEAD_MAX, 
+              "send_overhead", m_send_overhead_buf);
+#endif
+
     // Init binding to seqentializer
     if (my_core_id!=SEQUENTIALIZER) {
         qrm_sequentializer.binding = qrm_binding[SEQUENTIALIZER];
@@ -822,6 +844,10 @@
 
     printf("q%d: AB Experiement %d done!\n", my_core_id, j);
 
+#ifdef MEASURE_SEND_OVERHEAD
+    sk_m_print(&m_send_overhead);
+#endif
+
     if (my_core_id==sending_node) {
         sk_m_print(&m);
     }
diff --git a/usr/quorum/exp_hybrid.c b/usr/quorum/exp_hybrid.c
--- a/usr/quorum/exp_hybrid.c
+++ b/usr/quorum/exp_hybrid.c
@@ -88,62 +88,18 @@
 
 static void hybrid_ac(void)
 {
+    // Generally: do send and receive operations low level here .. 
 
-    if (is_coordinator(my_core_id)) {
+    // Message passing?
+    if (model_does_mp_receive(my_core_id) || model_does_mp_send(my_core_id)) {
 
-        // ==================================================
-        // COORDINATOR
+        if (my_core_id == SEQUENTIALIZER) {
+            
+        }
+    }
 
-        // --------------------------------------------------
-        // GLOBAL COMMUNICATION
-
-        if (my_core_id==SEQUENTIALIZER) {
-            
-            // message passing to coordinators on other NUMA nodes
-            for (coreid_t c=HYB_NUM_CORES_PER_NODE;
-                 c<HYB_NUM_CORES_PER_NODE*HYB_NUM_NODES;
-                 c+=HYB_NUM_CORES_PER_NODE) {
-                
-                QDBG("hybrid%d: sending message to %d\n", my_core_id, c);
-                mp_send(c);
-                QDBG("hybrid%d: sent message to %d\n", my_core_id, c);
-            }
-
-        } else {
-
-            // Wait for message from root
-            QDBG("hybrid%d: receiving message from %d\n",
-                 my_core_id, SEQUENTIALIZER);
-
-            mp_receive(SEQUENTIALIZER);
-
-            QDBG("hybrid%d: received message from %d\n",
-                 my_core_id, SEQUENTIALIZER);
-        }
-
-        // --------------------------------------------------
-        // LOCAL COMMUNICATION
-
-        /* QDBG("hybrid%d: shm sending on %d\n",  */
-        /*      my_core_id, get_local_numa_node()); */
-
-        shm_send(shmq, hybrid_round++);
-
-        /* QDBG("hybrid%d: shm sent on %d\n",  */
-        /*      my_core_id, get_local_numa_node()); */
-     
-    } else {
-
-        // ==================================================
-        // SLAVES
-
-        // --------------------------------------------------
-        // LOCAL COMMUNICATION
-
-        /* QDBG("hybrid%d: shm receving on %d\n",  */
-        /*      my_core_id, get_local_numa_node()); */
-
-        shm_receive(shmq, hybrid_round++);
+    // Shared memory
+    if (model_does_shm_send(my_core_id) || model_does_shm_receive(my_core_id)) {
     }
 
 }
diff --git a/usr/quorum/main.c b/usr/quorum/main.c
--- a/usr/quorum/main.c
+++ b/usr/quorum/main.c
@@ -21,6 +21,7 @@
 #include <barrelfish/nameservice_client.h>
 #include <skb/skb.h>
 #include <octopus/octopus.h>
+#include <tools/tools.h>
 
 #include <if/quorum_mgmt_defs.h>
 #include <if/quorum_defs.h>
@@ -41,6 +42,9 @@
 static int trace_done = 0;
 static int trace_init_done = 0;
 
+enum hyb_send_mode send_mode = SEND_NONE;
+enum hyb_receive_mode receive_mode = RECEIVE_NONE;
+
 void after_prepare(void *st)
 {
     trace_init_done = 1;
@@ -72,7 +76,7 @@
 struct sk_measurement m;
 
 struct capref shared_frame;
-union quorum_share *share;
+union quorum_share *share = NULL;
 union quroum_share *numa_share;
 
 /*
@@ -96,7 +100,8 @@
 };
 
 /*
- * \brief Check if there is an edge in the model for the given pair of cores
+ * \brief Check if there is message-passing connection in the model
+ * for the given pair of cores
  *
  * Also returns true for connection LAST_NODE <-> SEQUENTIALIZER
  */
@@ -105,16 +110,80 @@
     assert(src<num_cores);
     assert(dest<num_cores);
 
-    // Node s -> r implies node r -> s
-    assert(model[src][dest] == 0 || model[dest][src] > 0);
-    assert(model[dest][src] == 0 || model[src][dest] > 0);
+    // For MP: Node s -> r implies node r -> s
+    assert(model[src][dest] == 0 || model[src][dest]>=SHM_SLAVE_START || model[dest][src]>0);
+    assert(model[dest][src] == 0 || model[dest][src]>=SHM_SLAVE_START || model[src][dest]>0);
 
-    return model[src][dest] > 0 || 
+    return (model[src][dest]>0 && model[src][dest]<SHM_SLAVE_START) || 
+        (model[src][dest]==99) ||
         (src==SEQUENTIALIZER && dest==LAST_NODE) ||
         (dest==SEQUENTIALIZER && src==LAST_NODE);
 }
 
 /*
+ * \brief 
+ *
+ */
+static int model_is_parent(coreid_t core, coreid_t parent)
+{
+    return model[parent][core] == 99;
+}
+
+bool model_does_mp_send(coreid_t core)
+{
+    for (int i=0; i<MODEL_NUM_CORES; i++) {
+        
+        if (model_is_edge(core, i) && model_is_parent(core, i)) {
+
+            return true;
+        }
+    }
+
+    return false;
+}
+
+bool model_does_mp_receive(coreid_t core)
+{
+    for (int i=0; i<MODEL_NUM_CORES; i++) {
+        
+        if (model_is_edge(core, i) && !model_is_parent(core, i)) {
+
+            return true;
+        }
+    }
+
+    return false;
+}
+
+bool model_does_shm_send(coreid_t core)
+{
+    for (int i=0; i<MODEL_NUM_CORES; i++) {
+        
+        if (model[core][i]>=SHM_MASTER_START && model[core][i]<SHM_MASTER_MAX) {
+
+            assert(share != NULL);
+            return true;
+        }
+    }
+
+    return false;
+}
+
+bool model_does_shm_receive(coreid_t core)
+{
+    for (int i=0; i<MODEL_NUM_CORES; i++) {
+        
+        if (model[core][i]>=SHM_SLAVE_START && model[core][i]<SHM_SLAVE_MAX) {
+
+            assert(share != NULL);
+            return true;
+        }
+    }
+
+    return false;
+}
+
+/*
  * \brief Check if there is an edge in the model to the given core
  *
  */
@@ -521,6 +590,7 @@
 static void start(void *arg);
 int main(int argc, char *argv[])
 {
+    assert(LAST_NODE!=SEQUENTIALIZER);
     share = NULL; // Shared page not yet mapped
     printf("quorum on core %d\n", disp_get_core_id());
     printf("NODE: %d\n", disp_get_core_id());
@@ -589,12 +659,17 @@
 #endif
 
     connect_to_mgmt_process();
-    qrm_init_finish_round();
+    printff("Connection to mgmt process done\n");
 
     uint64_t ts = rdtsc();
 
 #if defined(EXP_MP) || defined(EXP_HYBRID)
     qrm_init();
+    printff("MP init done\n");
+#endif /* EXP_MP */
+
+#if defined(EXP_SHM) || defined(EXP_HYBRID)
+    shm_init_queues_from_model((int*) model);
 #endif /* EXP_MP */
 
     printf("qrm_init %d done after %"PRIu64"\n", my_core_id, rdtsc()-ts);
diff --git a/usr/quorum/model.h b/usr/quorum/model.h
--- a/usr/quorum/model.h
+++ b/usr/quorum/model.h
@@ -1,1 +1,1 @@
-hybrid_model.h
\ No newline at end of file
+ab_model.h
\ No newline at end of file
diff --git a/usr/quorum/model_defs.h b/usr/quorum/model_defs.h
--- a/usr/quorum/model_defs.h
+++ b/usr/quorum/model_defs.h
@@ -1,1 +1,1 @@
-hybrid_model_defs.h
\ No newline at end of file
+ab_model_defs.h
\ No newline at end of file
diff --git a/usr/quorum/quorum.h b/usr/quorum/quorum.h
--- a/usr/quorum/quorum.h
+++ b/usr/quorum/quorum.h
@@ -36,6 +36,7 @@
 #define SEQUENTIALIZER 0 // node that acts as the sequentializer
 #define SHM_SIZE (4096*1024) // 4 KB
 #define EXP_MP 1 // Enable message passing
+//#define MEASURE_SEND_OVERHEAD 1 // Measure overhead of send_node_payload_raw
 //#define EXP_SHM 1 // Enable shared memory
 //#define EXP_HYBRID 1 // Enable hybrid broadcast
 //#define QRM_DBG_ENABLED 1
@@ -43,6 +44,18 @@
 // --------------------------------------------------
 // DATA STRUCTURES
 
+enum hyb_send_mode {
+    SEND_NONE,
+    SEND_MP,
+    SEND_SHM
+};
+
+enum hyb_receive_mode {
+    RECEIVE_NONE,
+    RECEIVE_MP,
+    RECEIVE_SHM
+};
+
 struct node {
     struct quorum_binding *binding;
     struct node *next;
@@ -93,6 +106,11 @@
 void update_bindings(struct quorum_rx_vtbl *vtbl);
 void qrm_exp_round(void);
 
+bool model_does_mp_send(coreid_t core);
+bool model_does_mp_receive(coreid_t core);
+bool model_does_shm_send(coreid_t core);
+bool model_does_shm_receive(coreid_t core);
+
 // managment connection (mgmt_connection)
 void connect_to_mgmt_process(void);
 void quorum_init_reply(struct quorum_mgmt_binding *b, struct capref sm, struct capref numa_sm);
diff --git a/usr/quorum/shm.h b/usr/quorum/shm.h
--- a/usr/quorum/shm.h
+++ b/usr/quorum/shm.h
@@ -13,10 +13,13 @@
 #include <barrelfish/barrelfish.h>
 #include <barrelfish/ump_impl.h>
 
+#define SHM_REGION_BITS BASE_PAGE_BITS
+#define SHM_REGION_SIZE BASE_PAGE_SIZE
 #define SHM_Q_MAX 250
 
 void shm_send(volatile struct ump_message *fifo, uintptr_t round);
 void shm_receive(volatile struct ump_message *fifo, uintptr_t round);
 void shm_reset_queue(volatile struct ump_message *fifo);
+void shm_init_queues_from_model(int *model);
 
 #endif
diff --git a/usr/quorum/shm_fifo_queue.c b/usr/quorum/shm_fifo_queue.c
--- a/usr/quorum/shm_fifo_queue.c
+++ b/usr/quorum/shm_fifo_queue.c
@@ -9,16 +9,21 @@
 
 #include "shm.h"
 #include "quorum.h"
+#include "model_defs.h"
 #include <tools/tools.h>
 
 #include <barrelfish_kpi/types.h>
 #include <barrelfish/barrelfish.h>
 #include <barrelfish/ump_impl.h>
 
+#include <octopus/capability_storage.h>
+#include <numa.h>
+
 #include <stdio.h>
 #include <measurement_framework.h>
 
 extern union quorum_share *share;
+extern coreid_t my_core_id;
 
 static uint64_t m_buf[NUM_REPETITIONS];
 static struct sk_measurement m;
@@ -115,6 +120,101 @@
 }
 
 /*
+ * \brief Map the frame pointed to by given capref
+ *
+ */
+static void shm_map(struct capref ref)
+{
+    void *vaddr;
+    errval_t err = vspace_map_one_frame_attr(&vaddr, 
+                                             SHM_REGION_BITS, 
+                                             ref,
+                                             VREGION_FLAGS_READ_WRITE,
+                                             NULL, NULL);
+    DEBUG_ERRR(err, "mapping shared frame\n");
+
+    share = (union quorum_share *) vaddr;
+}
+
+/*
+ * \brief Initialize shared memory queus as given by model
+ *
+ * A shared memory region is represented by an identifier in range
+ * SHM_SLAVE_START to SHM_SLAVE_MAX as well as SHM_MASTER_START to
+ * SHM_MASTER_MAX. The latter one indicates that the process acts as
+ * coordinator, which means that it is responsible for setting up the
+ * shared page (on its local NUMA node) and also for receiving the
+ * message-passing based message along the tree and writing it to
+ * shared memory.
+ */
+static int max_shm_id = -1;
+void shm_init_queues_from_model(int *model)
+{
+    errval_t err;
+    int value;
+    struct capref dest;
+
+    for (int x=0; x<MODEL_NUM_CORES; x++) {
+
+        value = model[my_core_id*MODEL_NUM_CORES+x];
+
+        if (value>=SHM_MASTER_START && value<SHM_MASTER_MAX) {
+            
+            // Get region identifier from model
+            value -= SHM_MASTER_START;
+
+            // Convert to identifier to string
+            char skey[128];
+            snprintf(skey, 128, "%d", value);
+
+            // Check if we already saw a request for this memory region before
+            if (value>max_shm_id) {
+                printff("SHM coord for region %d\n", value);
+
+                // Allocate memory on local NUMA domain
+                err = numa_frame_alloc_local(&dest, SHM_REGION_SIZE);
+                DEBUG_ERRR(err, "NUMA frame alloc\n");
+
+                // Put capability in octopus
+                err = oct_put_capability(skey, dest);
+                DEBUG_ERRR(err, "Putting capability in octopus\n");
+
+                // Map
+                shm_map(dest);
+            }
+
+            max_shm_id = value;
+        } 
+
+        else if(value>=SHM_SLAVE_START && value<SHM_SLAVE_MAX) {
+            
+            printff("SHM slave for region %d\n", value);
+
+            value -= SHM_SLAVE_START;
+            assert(value>max_shm_id);
+            value = max_shm_id;
+
+            // Convert to identifier to string
+            char skey[128];
+            snprintf(skey, 128, "%d", value);
+
+            // Get capability for octopus
+            // This might fail if the capability has not yet been put
+            // there by the master, in which case we just retry.
+            do {
+                err = oct_get_capability(skey, &dest);
+            } while(err_is_fail(err) && err_no(err)==OCT_ERR_CAP_NAME_UNKNOWN);
+
+            DEBUG_ERRR(err, "Getting capability from octopus failed\n");
+
+            // Map
+            shm_map(dest);
+        }
+
+    }
+}
+
+/*
  * \brief 
  *
  */
