diff --git a/hake/ArchDefaults.hs b/hake/ArchDefaults.hs
--- a/hake/ArchDefaults.hs
+++ b/hake/ArchDefaults.hs
@@ -84,6 +84,7 @@
 -- Libraries that are linked to all applications.
 stdLibs arch = 
     [ In InstallTree arch "/lib/libbarrelfish.a",
+      In InstallTree arch "/lib/libump.a",
       In InstallTree arch "/lib/libskb.a", -- SK: need to be able to get number of cores in libbarrelfish
       In InstallTree arch "/lib/liboctopus_parser.a", -- XXX: For NS client in libbarrelfish
       In InstallTree arch "/errors/errno.o",
diff --git a/hake/Config.hs.template b/hake/Config.hs.template
--- a/hake/Config.hs.template
+++ b/hake/Config.hs.template
@@ -206,6 +206,10 @@
 oneshot_timer :: Bool
 oneshot_timer = False
 
+-- Activate NUMA aware buffer allocation for UMP globally
+ump_numa :: Bool
+ump_numa = False
+
 defines :: [RuleToken]
 defines = [ Str ("-D" ++ d) | d <- [  
              if microbenchmarks then "CONFIG_MICROBENCHMARKS" else "",
@@ -250,7 +254,8 @@
              if nxe_paging then "CONFIG_NXE" else "",
              if libc == "oldc" then "CONFIG_OLDC" else "CONFIG_NEWLIB",
              if oneshot_timer then "CONFIG_ONESHOT_TIMER" else "",
-             if use_kaluga_dvm then "USE_KALUGA_DVM" else ""
+             if use_kaluga_dvm then "USE_KALUGA_DVM" else "",
+             if ump_numa then "UMP_NUMA_WARE" else ""
              ], d /= "" ]
 
 -- Sets the include path for the libc
diff --git a/include/barrelfish/idc.h b/include/barrelfish/idc.h
--- a/include/barrelfish/idc.h
+++ b/include/barrelfish/idc.h
@@ -44,6 +44,9 @@
 
     // request a multi-hop channel
     IDC_BIND_FLAG_MULTIHOP = 1 << 2,
+    // do NUMA aware memory allocation
+    // currently only supported in UMP
+    IDC_BIND_FLAG_NUMA_AWARE = 1 << 3,
 } idc_bind_flags_t;
 
 #define IDC_BIND_FLAGS_DEFAULT 0
diff --git a/include/barrelfish/ump_chan.h b/include/barrelfish/ump_chan.h
--- a/include/barrelfish/ump_chan.h
+++ b/include/barrelfish/ump_chan.h
@@ -78,6 +78,12 @@
                        struct monitor_binding *monitor_binding,
                        size_t inchanlen, size_t outchanlen,
                        struct capref notify_cap);
+errval_t ump_chan_bind_numa(struct ump_chan *uc, 
+                            struct ump_bind_continuation cont,
+                            struct event_queue_node *qnode,  iref_t iref,
+                            struct monitor_binding *monitor_binding,
+                            size_t inchanlen, size_t outchanlen,
+                            struct capref notify_cap);
 errval_t ump_chan_accept(struct ump_chan *uc, uintptr_t mon_id,
                          struct capref frame, size_t inchanlen, size_t outchanlen);
 void ump_chan_send_bind_reply(struct monitor_binding *mb,
diff --git a/include/tools/tools.h b/include/tools/tools.h
--- a/include/tools/tools.h
+++ b/include/tools/tools.h
@@ -12,5 +12,7 @@
 #define TOOLS_H 1
 
 void tsc_sleep(uint64_t tics);
+void barrier_wait(int num);
+void printff(const char *fmt, ...);
 
 #endif /* TOOLS_H */
diff --git a/kernel/arch/x86_64/init.c b/kernel/arch/x86_64/init.c
--- a/kernel/arch/x86_64/init.c
+++ b/kernel/arch/x86_64/init.c
@@ -43,6 +43,8 @@
 #include <dev/ia32_dev.h>
 #include <dev/amd64_dev.h>
 
+lvaddr_t kernel_address = 0;
+
 /**
  * Used to store the address of global struct passed during boot across kernel
  * relocations.
@@ -607,6 +609,7 @@
     }
 
     // XXX: print kernel address for debugging with gdb
+    kernel_address = local_phys_to_mem(dest);
     printf("Kernel starting at address 0x%"PRIxLVADDR"\n",
            local_phys_to_mem(dest));
 
diff --git a/kernel/arch/x86_64/syscall.c b/kernel/arch/x86_64/syscall.c
--- a/kernel/arch/x86_64/syscall.c
+++ b/kernel/arch/x86_64/syscall.c
@@ -199,6 +199,7 @@
     err = caps_lookup_slot(&dcb_current->cspace.cap, cptr, bits,
                                     &mapping, CAPRIGHTS_READ_WRITE);
     if (err_is_fail(err)) {
+        printf("syscall.c\n");
         return SYSRET(err_push(err, SYS_ERR_CAP_NOT_FOUND));
     }
 
@@ -856,6 +857,7 @@
         retval.error = caps_lookup_cap(&dcb_current->cspace.cap, invoke_cptr,
                                        invoke_bits, &to, CAPRIGHTS_READ);
         if (err_is_fail(retval.error)) {
+            printf("caps_lookup_cap failed in sys_syscall\n");
             break;
         }
 
diff --git a/kernel/capabilities.c b/kernel/capabilities.c
--- a/kernel/capabilities.c
+++ b/kernel/capabilities.c
@@ -35,6 +35,7 @@
 /// Sets the specified number of low-order bits to 1
 #define MASK(bits)      ((1UL << bits) - 1)
 
+extern lvaddr_t kernel_address;
 struct capability monitor_ep;
 
 /**
@@ -639,6 +640,9 @@
     struct cte *next_slot = caps_locate_slot(cnode_cap->u.cnode.cnode, offset);
     // Do not return NULL type capability
     if (next_slot->cap.type == ObjType_Null) {
+        printf("callstack: %"PRIxLVADDR"\n", 
+               ((lvaddr_t)__builtin_return_address(0) - kernel_address));
+        printf("capabilities.c\n");
         return SYS_ERR_CAP_NOT_FOUND;
     }
 
@@ -670,6 +674,8 @@
     struct cte *ret_cte;
     errval_t err = caps_lookup_slot(cnode_cap, cptr, vbits, &ret_cte, rights);
     if (err_is_fail(err)) {
+        printf("callstack in caps_lookup_cap: %"PRIxLVADDR"\n", 
+               ((lvaddr_t) __builtin_return_address(0) - kernel_address));
         return err;
     }
     *ret = &ret_cte->cap;
@@ -882,6 +888,7 @@
     struct capability *dest_cap = &dest_cte->cap;
     // NULL caps cannot be copied/minted
     if (src_cap->type == ObjType_Null) {
+        printf("capabilities.c 2\n");
         return SYS_ERR_CAP_NOT_FOUND;
     }
     // Parameters should be 0 if not minting
diff --git a/lib/barrelfish/Hakefile b/lib/barrelfish/Hakefile
--- a/lib/barrelfish/Hakefile
+++ b/lib/barrelfish/Hakefile
@@ -12,10 +12,10 @@
 
 [(let arch_dir = "arch" ./. archFamily arch
       common_srcs = [ "capabilities.c", "init.c", "dispatch.c", "threads.c",
-                      "thread_sync.c", "slab.c", "domain.c", "idc.c",
-                      "waitset.c", "event_queue.c", "event_mutex.c",
-                      "idc_export.c", "nameservice_client.c", "msgbuf.c",
-                      "monitor_client.c", "flounder_support.c", "flounder_glue_binding.c",
+                      "thread_sync.c", "slab.c", "domain.c",
+                      "event_queue.c", "event_mutex.c",
+                      "nameservice_client.c", "msgbuf.c",
+                      "monitor_client.c",
                       "morecore.c", "debug.c", "heap.c", "ram_alloc.c",
                       "terminal.c", "spawn_client.c", "vspace/vspace.c", 
                       "vspace/vregion.c", "vspace/memobj_one_frame.c",
@@ -31,7 +31,7 @@
       idc_srcs = concat $ map getsrcs $ optInterconnectDrivers $ options arch
           where
             getsrcs "lmp" = [ "lmp_chan.c", "lmp_endpoints.c" ]
-            getsrcs "ump" = [ "ump_chan.c", "ump_endpoint.c" ]
+--            getsrcs "ump" = [ "ump_chan.c", "ump_endpoint.c" ]
             getsrcs "multihop" = [ "multihop_chan.c" ]
             getsrcs _ = []
 
diff --git a/lib/barrelfish/monitor_client.c b/lib/barrelfish/monitor_client.c
--- a/lib/barrelfish/monitor_client.c
+++ b/lib/barrelfish/monitor_client.c
@@ -19,6 +19,7 @@
 #include <if/monitor_blocking_rpcclient_defs.h>
 #include <string.h>
 #include <inttypes.h>
+#include <stdio.h>
 
 static void error_handler(struct monitor_binding *b, errval_t err)
 {
@@ -57,6 +58,7 @@
     // try to retrieve a message from the channel
     err = lmp_chan_recv(&b->chan, &msg, &cap);
     if (err_is_fail(err)) {
+        printf("WARNING: monitor_accept_recv_handler. Registering error_handler\n");
         if (err_no(err) == LIB_ERR_NO_LMP_MSG) {
             // nothing there, re-register
             struct event_closure recv_handler = {
@@ -82,6 +84,7 @@
     err = lmp_chan_alloc_recv_slot(&b->chan);
     if (err_is_fail(err)) {
         // XXX: report the error, but continue
+        printf("WARNING: monitor_accept_recv_handler. Registering error_handler 2\n");
         b->b.error_handler(&b->b, err_push(err, LIB_ERR_LMP_ALLOC_RECV_SLOT));
     }
 
@@ -117,6 +120,9 @@
     }
 
     /* setup error handler */
+    printf("WARNING: monitor_accept_recv_handler (%s). "
+           "Registering error_handler 3, callstack=%p\n",
+           disp_name(), __builtin_return_address(0));
     mcb->b.error_handler = error_handler;
 
     /* setup initial receive handlers */
diff --git a/lib/tools/Hakefile b/lib/tools/Hakefile
--- a/lib/tools/Hakefile
+++ b/lib/tools/Hakefile
@@ -11,7 +11,8 @@
 --------------------------------------------------------------------------
 
 [ build library { target = "tools",
-                  cFiles = [ "tools.c" ]
+                  cFiles = [ "tools.c" ],
+                  addLibraries = [ "octopus" ]
 --                  addIncludes = [ "/include/tools" ],
                 }
 ]
diff --git a/lib/tools/tools.c b/lib/tools/tools.c
--- a/lib/tools/tools.c
+++ b/lib/tools/tools.c
@@ -9,6 +9,10 @@
 
 #include <barrelfish/barrelfish.h>
 #include <tools/tools.h>
+#include <octopus/octopus.h>
+#include <stdio.h>
+
+static int oct_init_done = false;
 
 /*
  * \brief Wait given number of ticks before returning
@@ -19,3 +23,57 @@
     uint64_t start = rdtsc();
     while (rdtsc()-start < tics) ;
 }
+
+static void octopus_init(void) {
+
+    // Init octopus
+    errval_t err = oct_init();
+    if (err_is_fail(err)) {
+        USER_PANIC_ERR(err, "Unable to init octopus client library");
+    }
+
+    oct_init_done = true;
+}
+
+/*
+ * \brief Barrier enter
+ *
+ * XXX Should implement pthread barrier semantics
+ *
+ * \param num Number of threads expected to enter the barrier
+ *
+ */
+void barrier_wait(int num)
+{
+    if (!oct_init_done) {
+        octopus_init();
+    }
+
+    static int round = 0;
+    char *dummy;
+    char name[100];
+    sprintf(name, "tools_round_%d", round);
+    oct_barrier_enter(name, &dummy, num);
+    oct_barrier_leave(dummy);
+}
+
+/*
+ * \brief Like debug_printf, but using printf instead of sys_print
+ *
+ */
+
+void printff(const char *fmt, ...)
+{
+    va_list argptr;
+    char str[256];
+    size_t len;
+
+    len = snprintf(str, sizeof(str), "%.*s.%u: ", DISP_NAME_LEN, disp_name(),
+                   disp_get_core_id());
+    if (len < sizeof(str)) {
+        va_start(argptr, fmt);
+        vsnprintf(str + len, sizeof(str) - len, fmt, argptr);
+        va_end(argptr);
+    }
+    printf(str, sizeof(str));
+}
diff --git a/lib/barrelfish/ump_chan.c b/lib/ump/ump_chan.c
rename from lib/barrelfish/ump_chan.c
rename to lib/ump/ump_chan.c
--- a/lib/barrelfish/ump_chan.c
+++ b/lib/ump/ump_chan.c
@@ -18,6 +18,12 @@
 #include <barrelfish/idc_export.h>
 #include <if/monitor_defs.h>
 
+#ifdef UMP_NUMA_AWARE
+#include <numa.h>
+#include <stdio.h>
+#include <barrelfish/dispatch.h>
+#endif
+
 /* UMP channels need to be mapped non-cacheable on SCC */
 #ifdef __scc__
 #  include <barrelfish_kpi/shared_mem_arch.h>
@@ -226,11 +232,13 @@
  * \param outchanlen Size of outgoing channel, in bytes (rounded to #UMP_MSG_BYTES)
  * \param notify_cap Capability to use for notifications, or #NULL_CAP
  */
-errval_t ump_chan_bind(struct ump_chan *uc, struct ump_bind_continuation cont,
-                       struct event_queue_node *qnode,  iref_t iref,
-                       struct monitor_binding *monitor_binding,
-                       size_t inchanlen, size_t outchanlen,
-                       struct capref notify_cap)
+static errval_t ump_chan_bind_impl(struct ump_chan *uc, 
+                                   struct ump_bind_continuation cont,
+                                   struct event_queue_node *qnode,  iref_t iref,
+                                   struct monitor_binding *monitor_binding,
+                                   size_t inchanlen, size_t outchanlen,
+                                   struct capref notify_cap,
+                                   bool numa)
 {
     errval_t err;
 
@@ -244,10 +252,25 @@
     ram_set_affinity(SHARED_MEM_MIN + (PERCORE_MEM_SIZE * disp_get_core_id()),
                      SHARED_MEM_MIN + (PERCORE_MEM_SIZE * (disp_get_core_id() + 1)));
 #endif
+
+#ifdef UMP_NUMA_AWARE
+    if (numa) {
+        printf("%s:Using NUMA aware UMP channel\n", disp_name());
+        numa_init();
+        err = numa_frame_alloc_local(&uc->frame, framesize);
+    } else {
+        err = frame_alloc(&uc->frame, framesize, &framesize);
+    }
+    if (err_is_fail(err)) {
+        return err_push(err, LIB_ERR_FRAME_ALLOC);
+    }
+#else
     err = frame_alloc(&uc->frame, framesize, &framesize);
     if (err_is_fail(err)) {
         return err_push(err, LIB_ERR_FRAME_ALLOC);
     }
+#endif
+
 #ifdef __scc__
     ram_set_affinity(0, 0);
 #endif
@@ -296,6 +319,27 @@
     return SYS_ERR_OK;
 }
 
+errval_t ump_chan_bind(struct ump_chan *uc, struct ump_bind_continuation cont,
+                       struct event_queue_node *qnode,  iref_t iref,
+                       struct monitor_binding *monitor_binding,
+                       size_t inchanlen, size_t outchanlen,
+                       struct capref notify_cap)
+{
+    return ump_chan_bind_impl(uc, cont, qnode, iref, monitor_binding, inchanlen,
+                              outchanlen, notify_cap, false);
+}
+
+errval_t ump_chan_bind_numa(struct ump_chan *uc, 
+                            struct ump_bind_continuation cont,
+                            struct event_queue_node *qnode,  iref_t iref,
+                            struct monitor_binding *monitor_binding,
+                            size_t inchanlen, size_t outchanlen,
+                            struct capref notify_cap)
+{
+    return ump_chan_bind_impl(uc, cont, qnode, iref, monitor_binding, inchanlen,
+                              outchanlen, notify_cap, true);
+}
+
 /**
  * \brief Initialise a new UMP channel to accept an incoming binding request
  *
diff --git a/lib/barrelfish/ump_endpoint.c b/lib/ump/ump_endpoint.c
rename from lib/barrelfish/ump_endpoint.c
rename to lib/ump/ump_endpoint.c
diff --git a/tools/flounder/UMPCommon.hs b/tools/flounder/UMPCommon.hs
--- a/tools/flounder/UMPCommon.hs
+++ b/tools/flounder/UMPCommon.hs
@@ -333,27 +333,51 @@
                 [C.Variable (new_monitor_cont_fn_name p ifn),
                  my_bindvar, C.Variable "waitset",
                  C.Variable "DEFAULT_LMP_BUF_WORDS"]
-            ]
-
-            -- no monitor binding, but do we need to alloc notify state?
-            (if isJust (ump_bind_alloc_notify p)
-            then
-                [C.Ex $ C.Assignment (chanvar `C.FieldOf` "monitor_binding")
-                                     (C.Call "get_monitor_binding" []),
-                 C.StmtList $ (fromJust $ ump_bind_alloc_notify p) ifn,
-                 C.If (C.Call "err_is_fail" [errvar])
-                    [C.Ex $ C.Assignment errvar $ C.Call "err_push"
-                     [errvar, C.Variable "FLOUNDER_ERR_UMP_ALLOC_NOTIFY"]] [] ]
-            else -- nothing special, just call bind
-                [C.Ex $ C.Assignment errvar $ C.Call "ump_chan_bind"
-                    [C.AddressOf $ statevar `C.FieldOf` "chan",
+            ][ C.If (C.Binary C.BitwiseAnd (C.Variable "flags") (C.Variable "IDC_BIND_FLAG_NUMA_AWARE")) 
+               -- ------------------------------
+               -- NUMA aware bind
+               -- no monitor binding, but do we need to alloc notify state?
+               (if isJust (ump_bind_alloc_notify p)
+                then
+                  [C.Ex $ C.Assignment (chanvar `C.FieldOf` "monitor_binding")
+                   (C.Call "get_monitor_binding" []),
+                   C.StmtList $ (fromJust $ ump_bind_alloc_notify p) ifn,
+                   C.If (C.Call "err_is_fail" [errvar])
+                   [C.Ex $ C.Assignment errvar $ C.Call "err_push"
+                    [errvar, C.Variable "FLOUNDER_ERR_UMP_ALLOC_NOTIFY"]] [] ]
+                else -- nothing special, just call bind
+                  [C.Ex $ C.Assignment errvar $ C.Call "ump_chan_bind_numa"
+                   [C.AddressOf $ statevar `C.FieldOf` "chan",
                      C.StructConstant "ump_bind_continuation"
                         [("handler", C.Variable (bind_cont_fn_name p ifn)),
                          ("st", my_bindvar)],
                      C.AddressOf $ intf_bind_var `C.FieldOf` "event_qnode",
                      C.Variable "iref", C.Call "get_monitor_binding" [],
                      C.Variable "inchanlen", C.Variable "outchanlen",
-                     C.Variable "NULL_CAP"]]),
+                     C.Variable "NULL_CAP"]])
+               -- ------------------------------
+               -- _not_ using NUMA aware bind
+               -- no monitor binding, but do we need to alloc notify state?
+               (if isJust (ump_bind_alloc_notify p)
+                then
+                  [C.Ex $ C.Assignment (chanvar `C.FieldOf` "monitor_binding")
+                   (C.Call "get_monitor_binding" []),
+                   C.StmtList $ (fromJust $ ump_bind_alloc_notify p) ifn,
+                   C.If (C.Call "err_is_fail" [errvar])
+                   [C.Ex $ C.Assignment errvar $ C.Call "err_push"
+                    [errvar, C.Variable "FLOUNDER_ERR_UMP_ALLOC_NOTIFY"]] [] ]
+                else -- nothing special, just call bind
+                  [C.Ex $ C.Assignment errvar $ C.Call "ump_chan_bind"
+                   [C.AddressOf $ statevar `C.FieldOf` "chan",
+                    C.StructConstant "ump_bind_continuation"
+                    [("handler", C.Variable (bind_cont_fn_name p ifn)),
+                     ("st", my_bindvar)],
+                    C.AddressOf $ intf_bind_var `C.FieldOf` "event_qnode",
+                    C.Variable "iref", C.Call "get_monitor_binding" [],
+                    C.Variable "inchanlen", C.Variable "outchanlen",
+                    C.Variable "NULL_CAP"]])
+             ],
+
         C.SBlank,
         C.If (C.Call "err_is_fail" [errvar])
             [C.Ex $ C.Call (destroy_fn_name p ifn) [my_bindvar]] [],
diff --git a/usr/bench/ump_bench/Hakefile b/usr/bench/ump_bench/Hakefile
--- a/usr/bench/ump_bench/Hakefile
+++ b/usr/bench/ump_bench/Hakefile
@@ -23,5 +23,5 @@
   build application { target = "ump_receive", cFiles = [ "main.c" , "receive.c" ],
                       flounderDefs = [ "monitor" ],
                       flounderBindings = [ "bench" ],
-                      addLibraries = ["bench","tools"] }
+                      addLibraries = ["bench","tools","ump_numa","numa"] }
 ]
diff --git a/usr/bench/ump_bench/main.c b/usr/bench/ump_bench/main.c
--- a/usr/bench/ump_bench/main.c
+++ b/usr/bench/ump_bench/main.c
@@ -15,14 +15,19 @@
 #include "ump_bench.h"
 #include <stdlib.h>
 #include <string.h>
+#include <stdbool.h>
 #include <barrelfish/nameservice_client.h>
 #include <barrelfish/spawn_client.h>
 #include <skb/skb.h>
 #include <tools/tools.h>
+#include <numa.h>
 
 static coreid_t num_cores;
 static char my_name[100];
 
+static coreid_t sending_core;
+static bool exp_done = false;
+
 static struct timestamps *timestamps;
 
 struct bench_binding *array[MAX_CPUS] = {NULL};
@@ -42,9 +47,9 @@
             }
         }
 
-        printf("client done\n"); // Only once (the receiving core?)
-        printf("%d terminating\n", my_core_id);
-        exit(0); // Terminate the client
+        printf("client done\n");
+        exp_done = true;
+        count = 0;
     }
 }
 
@@ -69,11 +74,12 @@
     assert(timestamps != NULL);
 
     int i = 0;
+    printf("bind_cb on core %d. Starting event handling loop\n", my_core_id);
 
     /* Wait for and reply to msgs */
     /* This is running on the client! */
     printf("client: Running low-level event dispatching loop in bind_cb\n");
-    while (1) {
+    while (!exp_done) {
         volatile struct ump_message *msg;
         struct ump_control ctrl;
         do {
@@ -87,7 +93,7 @@
         if (i == MAX_COUNT) {
 
             printf("received messages from all cores, terminating\n");
-            exit(0);
+            exp_done = true;
         }
 
 #ifdef SERVERCOST
@@ -115,8 +121,15 @@
         abort();
     }
 
+    assert(sending_core == my_core_id);
+
+    char buf[1000];
+    sprintf(buf, "ump_server%d", sending_core);
+
+    printf("export_cb: registering %s\n", buf);
+
     // register this iref with the name service
-    err = nameservice_register("ump_server", iref);
+    err = nameservice_register(buf, iref);
     if (err_is_fail(err)) {
         DEBUG_ERR(err, "nameservice_register failed");
         abort();
@@ -125,6 +138,8 @@
 
 static errval_t connect_cb(void *st, struct bench_binding *b)
 {
+    printf("connect_cb on core %d\n", my_core_id);
+
     // copy my message receive handler vtable to the binding
     b->rx_vtbl = rx_vtbl;
 
@@ -162,6 +177,7 @@
     if (err_is_fail(err)) {
         USER_PANIC_ERR(err, "connection to SKB failed");
     }
+    numa_init();
 
     /* Set my core id */
     my_core_id = disp_get_core_id();
@@ -169,7 +185,7 @@
 
     bench_init();
 
-
+#if 0
     if (argc == 2 && strcmp(argv[1], "master")==0) {
 
         num_cores = get_num_cores();
@@ -177,7 +193,9 @@
         for (int i=0; i<num_cores; i++) {
             
             domainid_t domainid;
-            uint8_t exitcode;
+            /* uint8_t exitcode; */
+
+            tsc_sleep(100000); // Wait a bit for monitor free up buffer space
 
             // Start benchmark server on core 1
             printf("MASTER: Spawning new benchmark server on core %d\n", i);
@@ -191,20 +209,26 @@
             assert(err_is_ok(err));
 
             // Wait for termination
-            printf("MASTER: Waiting for %d to terminate\n", domainid);
-            err = spawn_wait_coreid(i, domainid, &exitcode, false);
-            printf("MASTER: %d terminated with %d\n", domainid, exitcode);
+            /* printf("MASTER: Waiting for %d to terminate\n", domainid); */
+            /* err = spawn_wait_coreid(i, domainid, &exitcode, false); */
+            /* printf("MASTER: %d terminated with %d\n", domainid, exitcode); */
             
-            // Check?
-            DEBUG_ERR(err, "waiting for child to terminate");
-            assert(err_is_ok(err));
+            /* // Check? */
+            /* DEBUG_ERR(err, "waiting for child to terminate"); */
+            /* assert(err_is_ok(err)); */
 
+            barrier_wait(2);
+            
             tsc_sleep(2000000); // 1 second?
         }
 
         printf("benchmark master terminated\n");
     }
+#endif
 
+    num_cores = get_num_cores();
+    
+    // Start all other clients
     if (argc == 1) { /* bsp core */
 
         /* 1. set num_cores,
@@ -213,7 +237,6 @@
            4. wait for all clients to connect,
            5. run experiments
         */
-        num_cores = get_num_cores();
 
         // Spawn domains
         char *xargv[] = {my_name, "dummy", NULL};
@@ -221,30 +244,76 @@
                                          SPAWN_FLAGS_DEFAULT, NULL);
         DEBUG_ERR(err, "spawn program on all cores");
         assert(err_is_ok(err));
+    }
 
-        /* Setup a server */
-        err = bench_export(NULL, export_cb, connect_cb, get_default_waitset(),
-                           IDC_BIND_FLAGS_DEFAULT);
-        assert(err_is_ok(err));
-    } else {
-        /* Connect to the server */
-        iref_t iref;
+    barrier_wait(num_cores);
+    
+    for (sending_core=0; sending_core<num_cores; sending_core++) {
 
-        err = nameservice_blocking_lookup("ump_server", &iref);
-        if (err_is_fail(err)) {
-            DEBUG_ERR(err, "nameservice_blocking_lookup failed");
-            abort();
+        tsc_sleep(10000);
+
+        printf("Starting experiments for sender %d\n", sending_core);
+        exp_done = false;
+
+        if (sending_core == my_core_id) {
+
+            /* Setup a server */
+            err = bench_export(NULL, export_cb, connect_cb, 
+                               get_default_waitset(), IDC_BIND_FLAGS_DEFAULT);
+            assert(err_is_ok(err));
+
+
+        } else {
+
+            /* Connect to the server */
+            iref_t iref;
+
+            char buf[1000];
+            sprintf(buf, "ump_server%d", sending_core);
+
+            err = nameservice_blocking_lookup(buf, &iref);
+            if (err_is_fail(err)) {
+                DEBUG_ERR(err, "nameservice_blocking_lookup failed");
+                abort();
+            }
+            
+            printf("bind on core %d\n", my_core_id);
+            err = bench_bind(iref, bind_cb, NULL, get_default_waitset(), 
+                             IDC_BIND_FLAGS_DEFAULT | IDC_BIND_FLAG_NUMA_AWARE);
+            if (err_is_fail(err)) {
+                DEBUG_ERR(err, "bind failed");
+                abort();
+            }
+            printf("bind on core %d terminated\n", my_core_id);
+                
         }
 
-        err = bench_bind(iref, bind_cb, NULL,
-                         get_default_waitset(), IDC_BIND_FLAGS_DEFAULT);
-        if (err_is_fail(err)) {
-            DEBUG_ERR(err, "bind failed");
-            abort();
+        // Run event non-blocking dispatching loop until benchmark is complete
+        // Can't use blocking calls here due to the wiredness with barriers .. 
+        printf("Running event processing loops\n");
+        while (!exp_done) {
+            err = event_dispatch_non_block(get_default_waitset());
+            
+            if (err_is_fail(err)) {
+
+                if (err_no(err) == LIB_ERR_NO_EVENT) {
+                    // No message
+
+                } else {
+                    USER_PANIC_ERR(err, "error in event_dispatch");
+                }
+            }
+
         }
-                
+
+        printff("Experiments done, barrrier\n");
+        barrier_wait(num_cores);
+
     }
 
-    printf("messages_handler_loop on core %d\n", disp_get_core_id());
-    messages_handler_loop();
+    printff("everything done, terminating\n");
+
+    if (my_core_id==0) {
+        printf("ump_bench done\n");
+    }
 }
diff --git a/usr/bench/ump_bench/ump_bench.h b/usr/bench/ump_bench/ump_bench.h
--- a/usr/bench/ump_bench/ump_bench.h
+++ b/usr/bench/ump_bench/ump_bench.h
@@ -26,7 +26,7 @@
 #include <if/bench_defs.h>
 
 #define NUM_MSGS 16
-#define MAX_COUNT 1000
+#define MAX_COUNT 100
 
 struct timestamps {
     cycles_t time0;
